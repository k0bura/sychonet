---
import Base from '../layouts/Base.astro';
---

<Base title="Message Wall - sych0net" description="Leave a message on the wall">
  <div class="section-header">
    <pre>{`
▒▒▒ MESSAGE WALL ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒`}</pre>
  </div>

  <div id="wall-messages">
    <p class="wall-loading">Loading messages...</p>
  </div>

  <pre class="wall-divider modem-line">─────────────────────────────────────────────────────────────────────────────</pre>

  <form id="wall-form" class="modem-line" autocomplete="off">
    <div class="form-row">
      <label>&gt;</label>
      <input type="text" id="wall-name" maxlength="20" placeholder="ANON" size="12" />
      <label>:</label>
      <input type="text" id="wall-msg" maxlength="140" placeholder="leave a one liner..." required />
      <button type="submit" id="wall-submit">[ POST ]</button>
    </div>
    <div class="form-status"><span id="wall-status"></span></div>
  </form>

  <p><a href="/">&larr; back to main [ESC]</a></p>
</Base>

<style>
  .section-header pre {
    color: #ffcc00;
    background: none !important;
    border: none !important;
    padding: 0 !important;
    margin: 0 0 0.5rem 0;
    overflow: hidden;
  }

  form {
    margin: 1rem 0;
  }

  .form-row {
    margin: 0.4rem 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  label {
    color: #665200;
    white-space: nowrap;
  }

  input[type="text"] {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 1em;
    background: #1a1a1a;
    color: #c0c0c0;
    border: 1px solid #332b00;
    padding: 0.3rem 0.5rem;
  }

  #wall-name {
    width: 12ch;
    flex: 0 0 auto;
  }

  #wall-msg {
    flex: 1;
  }

  input[type="text"]::placeholder {
    color: #444;
  }

  input[type="text"]:focus {
    outline: none;
    border-color: #665200;
  }

  button {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 1em;
    background: #1a1a1a;
    color: #88cc88;
    border: 1px solid #332b00;
    padding: 0.3rem 0.8rem;
    cursor: pointer;
  }

  button:hover {
    background: #88cc88;
    color: #111;
  }

  button:disabled {
    color: #444;
    cursor: not-allowed;
  }

  button:disabled:hover {
    background: #1a1a1a;
    color: #444;
  }

  .form-status {
    min-height: 1.4em;
  }

  #wall-status {
    color: #665200;
    font-size: 0.9em;
  }

  .wall-divider {
    color: #332b00;
    background: none !important;
    border: none !important;
    padding: 0 !important;
    margin: 0;
  }

  .wall-loading {
    color: #665200;
  }

  .modem-line {
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: opacity 0.15s ease-in, max-height 0.15s ease-in;
  }

  .modem-line.visible {
    opacity: 1;
    max-height: 10em;
  }

  :global(.wall-entry) {
    margin: 0;
    padding: 0;
    line-height: 1.3;
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: opacity 0.15s ease-in, max-height 0.15s ease-in;
  }

  :global(.wall-entry.visible) {
    opacity: 1;
    max-height: 3em;
  }

  :global(.wall-name) {
    color: #ffcc00;
  }

  :global(.wall-loc) {
    color: #665200;
  }

  :global(.wall-text) {
    color: #c0c0c0;
  }

  :global(.wall-empty) {
    color: #665200;
  }
</style>

<script>
  const API_BASE = 'https://sychonet-wall.jeffy9.workers.dev';
  const API_URL = `${API_BASE}/api/wall`;
  const MODEM_DELAY = 150;
  const form = document.getElementById('wall-form') as HTMLFormElement;
  const nameInput = document.getElementById('wall-name') as HTMLInputElement;
  const msgInput = document.getElementById('wall-msg') as HTMLInputElement;
  const submitBtn = document.getElementById('wall-submit') as HTMLButtonElement;
  const status = document.getElementById('wall-status')!;
  const container = document.getElementById('wall-messages')!;
  const modemLines = document.querySelectorAll('.modem-line');

  function escapeHtml(s: string) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  function renderEntry(entry: { name: string; location?: string; message: string; date: string }) {
    const div = document.createElement('div');
    div.className = 'wall-entry';
    const dateStr = entry.date.split('T')[0];
    const loc = entry.location ? `<span class="wall-loc">@${escapeHtml(entry.location)}</span>` : '';
    div.innerHTML = `<span class="wall-name">${escapeHtml(entry.name)}</span>${loc}: <span class="wall-text">${escapeHtml(entry.message)}</span>`;
    return div;
  }

  function revealTrailing(startIndex: number) {
    modemLines.forEach((el, i) => {
      setTimeout(() => el.classList.add('visible'), MODEM_DELAY * (startIndex + i));
    });
  }

  async function loadMessages() {
    try {
      const res = await fetch(API_URL);
      if (!res.ok) throw new Error();
      const messages = await res.json();
      container.innerHTML = '';
      if (messages.length === 0) {
        container.innerHTML = '<p class="wall-empty">No messages yet. Be the first.</p>';
        revealTrailing(1);
        return;
      }
      messages.forEach((entry: { name: string; message: string; date: string }) => {
        container.appendChild(renderEntry(entry));
      });
      const entries = container.querySelectorAll('.wall-entry');
      entries.forEach((el, i) => {
        setTimeout(() => el.classList.add('visible'), MODEM_DELAY * i);
      });
      revealTrailing(entries.length);
    } catch {
      container.innerHTML = '<p class="wall-empty">Failed to load messages. NO CARRIER</p>';
      revealTrailing(1);
    }
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const name = nameInput.value.trim() || 'ANON';
    const message = msgInput.value.trim();
    if (!message) return;

    submitBtn.disabled = true;
    status.textContent = 'Posting...';

    try {
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, message }),
      });

      if (!res.ok) {
        const data = await res.json().catch(() => ({ error: 'Post failed' }));
        status.textContent = data.error || 'Post failed';
        submitBtn.disabled = false;
        return;
      }

      const entry = await res.json();
      const emptyMsg = container.querySelector('.wall-empty');
      if (emptyMsg) emptyMsg.remove();
      const el = renderEntry(entry);
      container.prepend(el);
      requestAnimationFrame(() => el.classList.add('visible'));

      msgInput.value = '';
      status.textContent = 'Message posted.';
      setTimeout(() => { status.textContent = ''; }, 3000);
    } catch {
      status.textContent = 'Connection failed. NO CARRIER';
    }

    submitBtn.disabled = false;
  });

  loadMessages();
</script>
